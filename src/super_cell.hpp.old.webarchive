bplist00Ñ_WebMainResourceÕ	
_WebResourceTextEncodingName^WebResourceURL_WebResourceFrameName_WebResourceData_WebResourceMIMETypeUUTF-8_Rhttps://raw.githubusercontent.com/filipecosta90/im2model/master/src/super_cell.hppPO9ê<html><head></head><body><pre style="word-wrap: break-word; white-space: pre-wrap;">#ifndef SRC_SUPERCELL_H__
#define SRC_SUPERCELL_H__

/* BEGIN BOOST */
#include &lt;boost/iostreams/device/mapped_file.hpp&gt; // for mmap
#include &lt;boost/iostreams/stream.hpp&gt;             // for stream
/* END BOOST */

#include &lt;math.h&gt;                        // for fabs, ceil, pow, M_PI
#include &lt;algorithm&gt;                     // for max_element, min_element
#include &lt;cassert&gt;                       // for assert
#include &lt;cstdio&gt;                        // for perror, size_t, NULL, SEEK_END
#include &lt;iomanip&gt;                       // for operator&lt;&lt;, setfill, setw
#include &lt;iostream&gt;                      // for operator&lt;&lt;, basic_ostream
#include &lt;iterator&gt;                      // for distance
#include &lt;limits&gt;                        // for numeric_limits
#include &lt;string&gt;                        // for allocator, char_traits, to_s...
#include &lt;vector&gt;                        // for vector, vector&lt;&gt;::iterator
#include &lt;iosfwd&gt;                    // for string

#include &lt;opencv2/core/hal/interface.h&gt;  // for CV_8UC1, CV_32F, CV_32FC1
#include &lt;opencv2/imgproc/imgproc_c.h&gt;   // for cvGetSpatialMoment
#include &lt;opencv2/imgproc/types_c.h&gt;     // for ::CV_THRESH_BINARY, CvMoments
#include &lt;opencv2/core.hpp&gt;              // for minMaxLoc, normalize, Exception
#include &lt;opencv2/core/base.hpp&gt;         // for NormTypes::NORM_MINMAX, Code...
#include &lt;opencv2/core/cvstd.hpp&gt;        // for Ptr
#include &lt;opencv2/core/cvstd.inl.hpp&gt;    // for operator&lt;&lt;, String::String
#include &lt;opencv2/core/ptr.inl.hpp&gt;      // for Ptr::operator-&gt;, Ptr::Ptr&lt;T&gt;
#include &lt;opencv2/core/version.hpp&gt;      // for CV_MAJOR_VERSION
#include &lt;opencv2/features2d.hpp&gt;        // for SimpleBlobDetector::Params
#include &lt;opencv2/imgcodecs.hpp&gt;         // for imwrite
#include &lt;opencv2/imgproc.hpp&gt;           // for Canny, boundingRect, drawCon...
#include &lt;opencv2/video/tracking.hpp&gt;    // for findTransformECC, ::MOTION_E...
#include &lt;opencv2/core/mat.hpp&gt;      // for Mat
#include &lt;opencv2/core/mat.inl.hpp&gt;  // for Mat::~Mat
#include &lt;opencv2/core/matx.hpp&gt;     // for Vec4d
#include &lt;opencv2/core/types.hpp&gt;    // for Point3d, Point, Rect, Point2d

#include "unit_cell.hpp"
#include "td_map.hpp"
#include "base_image.hpp"

class Super_Cell {

  private:
    double _super_cell_length_a_Angstroms;
    double _super_cell_length_b_Angstroms;
    double _super_cell_length_c_Angstroms;
    double _super_cell_length_a_Nanometers;
    double _super_cell_length_b_Nanometers;
    double _super_cell_length_c_Nanometers;
    double _super_cell_volume;

    double _cell_angle_alpha;
    double _cell_angle_beta;
    double _cell_angle_gamma;

    /** supercell exclusive **/
    double _x_supercell_min_size_nm;
    double _y_supercell_min_size_nm;
    double _z_supercell_min_size_nm;

    cv::Mat inverse_orientation_matrix;
    cv::Point3d _a,_b,_c,_d,_e,_f,_g,_h;
    cv::Point3d _sim_a,_sim_b,_sim_c,_sim_d,_sim_e,_sim_f,_sim_g,_sim_h;

    int expand_factor_a = 1;
    int expand_factor_b = 1;
    int expand_factor_c = 1;

    /** Zone Axis / Lattice vector **/
    cv::Point3d zone_axis_vector_uvw;

    /** reciprocal-lattice (Miller) indices  **/
    cv::Point3d upward_vector_hkl;

    std::vector&lt;cv::Point3d&gt; _atom_positions;
    std::vector&lt;int&gt; _super_cell_to_unit_cell_pos;
    std::vector&lt;std::string&gt; _super_cell_atom_symbol_string;
    std::vector&lt;double&gt; _super_cell_atom_site_occupancy;
    std::vector&lt;double&gt; _super_cell_atom_debye_waller_factor;
    std::vector&lt;cv::Vec4d&gt; _atom_cpk_rgba_colors;
    std::vector&lt;double&gt; _atom_empirical_radii;

    /** .cel **/
    std::vector&lt;cv::Point3d&gt; _super_cell_atom_fractional_cell_coordinates;
    double _min_a_atom_pos, _max_a_atom_pos;
    double _min_b_atom_pos, _max_b_atom_pos;
    double _min_c_atom_pos, _max_c_atom_pos;
    double _fractional_norm_a_atom_pos;
    double _fractional_norm_b_atom_pos;
    double _fractional_norm_c_atom_pos;

    double _cel_margin_nm = 0.0f;
    double _super_cell_ab_margin = 0.0f;
    int _cel_margin_a_px = 0.0f;
    int _cel_margin_b_px = 0.0f;

    int _cel_nx_px;
    int _cel_ny_px;

    // used in the simulated super-cell. this is calculated based on _cel_nXY_px - 2 * _cel_margin_AB_px
    int _cel_wout_margin_nx_px;
    int _cel_wout_margin_ny_px;

    cv::Rect _ignore_cel_margin_rectangle;

    /** Orientation **/
    cv::Mat orientation_matrix;

    /** Unit Cell **/
    Unit_Cell* unit_cell;

    /** Simulated Crystal image related **/
    double super_cell_simulated_defocus_lower_bound;
    double super_cell_simulated_defocus_upper_bound;
    int super_cell_simulated_defocus_samples;
    double super_cell_simulated_defocus_period;

    std::string file_name_input_dat;

    /** Experimental image related **/

        BaseImage exp_image_properties;
        BaseImage sim_image_properties;

    cv::Mat _raw_experimental_image;
    cv::Mat _experimental_image_contours;
    bool _flag_raw_experimental_image = false;

    cv::Mat _experimental_image_roi;
    cv::Mat _experimental_image_roi_w_margin;
    cv::Mat _experimental_image_roi_mask;
    cv::Mat _experimental_image_roi_mask_w_margin;

    // _rectangle_cropped_experimental_image_w_margin is used for visualization ( the algorithms should use _experimental_image_roi_w_margin )
    cv::Mat _rectangle_cropped_experimental_image_w_margin;
    cv::Rect _experimental_image_boundary_rectangle;
    bool _flag_experimental_image_boundary_rectangle = false;

    cv::Rect _experimental_image_boundary_rectangle_w_margin;
    bool _flag_experimental_image_boundary_rectangle_w_margin = false;

    // the next 2 vectors are position-related to the whole experimental image
    std::vector&lt;cv::Point2i&gt; _experimental_image_boundary_polygon;
    bool _flag_experimental_image_boundary_polygon = false;
    std::vector&lt;cv::Point2i&gt; _experimental_image_boundary_polygon_w_margin;
    bool _flag_experimental_image_boundary_polygon_w_margin = false;

    // the next 2 vectors are position-related to the ROI of the experimental image
    std::vector&lt;cv::Point2i&gt; _experimental_image_roi_boundary_polygon;
    std::vector&lt;cv::Point2i&gt; _experimental_image_roi_boundary_polygon_w_margin;

    // vars for minMaxLoc to normalize simulated crystal images
    double experimental_image_minVal;
    double experimental_image_maxVal;

    double _experimental_image_boundary_polygon_margin_x_Nanometers;
    double _experimental_image_boundary_polygon_margin_y_Nanometers;
    double _experimental_image_thickness_margin_z_Nanometers;

    int _experimental_image_boundary_polygon_margin_width_px;
    int _experimental_image_boundary_polygon_margin_height_px;

    std::vector&lt;cv::Point2d&gt; _super_cell_boundary_polygon_Nanometers_w_margin;
    std::vector&lt;cv::Point&gt; _super_cell_boundary_polygon_px_w_margin;
    int _super_cell_min_width_px;
    int _super_cell_min_height_px;
    int _super_cell_left_padding_w_margin_px;
    int _super_cell_top_padding_w_margin_px;
    int _super_cell_left_padding_px;
    int _super_cell_top_padding_px;

    /*
     * _super_cell_width_px  and _super_cell_min_width_px may differ since
     * _super_cell_min_width_px reffers to the minimum acceptable width based on
     * the ZA and UV directions. _super_cell_width_px reffers to the width in pixels
     * based on the expand factor.
     *
     * _super_cell_width_px is ALWAYS &gt;= _super_cell_min_width_px
     * (same for _super_cell_height_px and _super_cell_min_height_px )
     *
     * */
    int _super_cell_width_px;
    int _super_cell_height_px;
    double _sampling_rate_super_cell_x_nm_pixel;
    double _sampling_rate_super_cell_y_nm_pixel;
    bool _flag_sampling_rate_super_cell_x_nm_pixel = false;
    bool _flag_sampling_rate_super_cell_y_nm_pixel = false;
    double _simgrid_best_match_thickness_nm;

    /** Defocus Map simulation related **/
    std::vector&lt;cv::Mat&gt; simulated_defocus_map_raw_images;
    std::vector&lt;cv::Point&gt; simulated_defocus_map_match_positions;
    std::vector&lt;double&gt; simulated_defocus_map_matches;
    std::vector&lt;double&gt; simulated_defocus_map_values;

    cv::Mat _best_match_simulated_image_raw;
    cv::Mat _best_match_simulated_image_positioned;
    cv::Rect _experimental_pos_best_match_rectangle;

    /***********
      super-cell boundaries vars
     ***********/

    cv::Point2f roi_center;
    bool _flag_roi_center = false;
    int _hysteresis_threshold = 85;
    int _max_contour_distance_px = 19;

    int _hysteresis_threshold_range_bottom_limit = 1;
    int _hysteresis_threshold_range_top_limit = 255;
    int  _max_contour_distance_px_range_bottom_limit = 1;
    int _max_contour_distance_px_range_top_limit = 255;

    /***********
      image alignement vars
     ***********/

    /////////////////////////
    // Im2Model core pointers
    /////////////////////////
    TDMap* _core_tdmap_ptr;

    // Define the motion model
    bool debug_switch = false;

    /** Private Class methods **/
    void set_default_values();
    void set_sentinel_values();
    void update_super_cell_length_parameters();
    void update_experimental_image_size_parameters();
  public:
    Super_Cell();
    Super_Cell( Unit_Cell* unit_cell );
    Super_Cell( TDMap* tdmap_ptr );

    // TDMap updaters

    bool _is_experimental_image_boundary_polygon_defined();
    bool _is_experimental_image_boundary_polygon_w_margin_defined();
    bool _is_experimental_image_boundary_polygon_rect_defined();
    bool _is_experimental_image_boundary_polygon_w_margin_rect_defined();

    //setters
    void set_super_cell_length_a_Angstroms( double a );
    void set_super_cell_length_b_Angstroms( double b );
    void set_super_cell_length_c_Angstroms( double c );

    void set_super_cell_length_a_Nanometers( double a );
    void set_super_cell_length_b_Nanometers( double b );
    void set_super_cell_length_c_Nanometers( double c );

    void set_super_cell_angle_alpha( double alpha );
    void set_super_cell_angle_beta( double beta );
    void set_super_cell_angle_gamma( double gamma );
    void set_super_cell_volume( double volume );
    void set_super_cell_zone_axis_vector( cv::Point3d uvw );
    void set_super_cell_upward_vector( cv::Point3d hkl );

    void set_super_cell_expand_factor_a( int factor_a );
    void set_super_cell_expand_factor_b( int factor_b );
    void set_super_cell_expand_factor_c( int factor_c );

    void set_experimental_image_boundary_polygon_margin_x_Nanometers( double margin );
    void set_experimental_image_boundary_polygon_margin_y_Nanometers( double margin );
    void set_experimental_image_thickness_margin_z_Nanometers( double margin );

    void set_experimental_min_size_nm_x( double x_min_size_nm );
    void set_experimental_min_size_nm_y( double y_min_size_nm );
    void set_experimental_min_size_nm_z( double z_min_size_nm );
    bool set_full_raw_experimental_image( cv::Mat full_raw_image );
    bool set_exp_image_properties_full_image( std::string path );
    void set_experimental_image( cv::Mat raw_image , double sampling_rate_exp_image_x_nm_pixel, double sampling_rate_exp_image_y_nm_pixel );
    bool set_sampling_rate_super_cell_x_nm_pixel( double sampling_rate );
    bool set_sampling_rate_super_cell_y_nm_pixel( double sampling_rate );
    void set_simgrid_best_match_thickness_nm( double tickness );
    void set_super_cell_margin_nm( double margin );

    void set_file_name_input_dat( std::string file_name_input_dat );
    void set_super_cell_simulated_defocus_lower_bound( double super_cell_simulated_defocus_lower_bound );
    void set_super_cell_simulated_defocus_upper_bound( double super_cell_simulated_defocus_upper_bound );
    void set_super_cell_simulated_defocus_samples( int super_cell_simulated_defocus_samples );
    void set_super_cell_simulated_defocus_period( double super_cell_simulated_defocus_period );

    bool set_hysteresis_threshold( int threshold );
    bool set_max_contour_distance_px( int max_distance );
    int get_hysteresis_threshold( );
    int get_max_contour_distance_px( );

    // threshold limits
    int get_hysteresis_threshold_range_bottom_limit( );
    int get_hysteresis_threshold_range_top_limit( );

    int  get_max_contour_distance_px_range_bottom_limit( );
    int  get_max_contour_distance_px_range_top_limit( );

    //getters
    cv::Mat get_target_region_contours_mat();
    double get_super_cell_length_a_Angstroms();
    double get_super_cell_length_b_Angstroms();
    double get_super_cell_length_c_Angstroms();
    double get_super_cell_length_a_Nanometers();
    double get_super_cell_length_b_Nanometers();
    double get_super_cell_length_c_Nanometers();
    std::vector&lt;cv::Point2i&gt; get_experimental_image_boundary_polygon_w_margin();
    std::vector&lt;cv::Point2i&gt; get_experimental_image_boundary_polygon();
    cv::Rect get_experimental_image_boundary_polygon_rect();
    cv::Rect get_experimental_image_boundary_polygon_w_margin_rect();

    double get_fractional_norm_a_atom_pos_Nanometers();
    double get_fractional_norm_b_atom_pos_Nanometers();
    double get_fractional_norm_c_atom_pos_Nanometers();

    std::vector&lt;cv::Point3d&gt; get_atom_positions_vec();
    std::vector&lt;cv::Vec4d&gt; get_atom_cpk_rgba_colors_vec();
    std::vector&lt;double&gt; get_atom_empirical_radii_vec();

    int get_super_cell_nx_px();
    int get_super_cell_ny_px();

    bool update_unit_cell_parameters();
    void update_super_cell_length_parameters_from_fractional_norms();
    void create_fractional_positions_atoms();
    bool create_atoms_from_unit_cell();
    void orientate_atoms_from_matrix();

    void set_experimental_min_size_nm_from_unit_cell();
    void calculate_experimental_min_size_nm();
    void calculate_expand_factor();
    bool calculate_supercell_boundaries_from_experimental_image();
    void calculate_supercell_boundaries_from_experimental_image( cv::Point2f roi_center, int threshold, int max_contour_distance_px );
    void update_super_cell_boundary_polygon();
    void remove_z_out_of_range_atoms();
    void remove_xy_out_of_range_atoms();
    void generate_super_cell_file(  std::string filename );
    void read_simulated_super_cell_from_dat_file( std::string file_name_input_dat );
    void read_simulated_super_cells_from_dat_files( );
    void match_experimental_simulated_super_cells( );
    void create_experimental_image_roi_mask_from_boundary_polygon();
    void calculate_atomic_columns_position_w_boundary_polygon();
};

#endif
</pre></body></html>Ztext/plain    ( F U l ~ ” š ï ð:Þ                           :é